<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Cyberracing</title>
</head>
<body style="margin: 0; padding: 0">
    <canvas id="game-canvas" style="display: block; width: 100%; height: 100%">
        Your browser doesn't appear to support the
        <code>&lt;canvas&gt;</code> element.
    </canvas>


<!--SHADERS-->
    <!--testing shader-->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec4 aColor;

        uniform mat4 uMMatrix;
        uniform mat4 uVMatrix;
        uniform mat4 uPMatrix;

        varying vec4 vColor;

        void main()
        {
            vColor = aColor;
            gl_Position = uPMatrix * uVMatrix * uMMatrix * vec4(aVertexPosition, 1.0);
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 vColor;

        void main()
        {
            gl_FragColor = vColor;
        }
    </script>

    <script id="vs-flat" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aFacePosition;
        attribute vec3 aFaceNormal;
        attribute vec3 aVertexNormal;

        uniform vec4 uMaterialColor;
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        uniform vec3 uCameraPosition;
        uniform int  uSpecularType;

        //lights
        uniform light_info uLight[64];
        uniform int uNumLights;
        uniform material_info uMaterial;


        varying vec4 vPolygonColor;

        struct light_info {
            int   type;
            vec4  color;
            vec4  position;
            vec4  direction;
            float angle;
        };
        struct material_info {
            float kA;
            float kD;
            float kS;
            float roughness;
        };

        // light types
        const int AMBIENT = 0;
        const int DIRECTIONAL = 1;
        const int POINT = 2;
        const int SPOT = 3;

        // specular types
        const int PHONG = 0;
        const int BLINN = 1;

        void main()
        {
            gl_Position = uMVPMatrix * vec4(aVertexPosition, 1.0);
            vec4 facePosition = PVMMatrix * vec4(aFacePosition, 1.0);

            //light
            vec4 ambientPart = uLight[0].color;
            vec4 diffusePart = vec4(0.0, 0.0, 0.0, 1.0);
            vec4 specularPart = vec4(0.0, 0.0, 0.0, 1.0;

            vec4 normal = uNormalMatrix * vec4(aVertexNormal, 1.0);

            vec3 vecToViewer = normalize(uCameraPosition - aVertexPosition);

            int max = min(uNumLights, 64);
            light_info l;
            float lambert;
            vec3 specVec;
            for(int i = 0, i < max; i++)
            {
                l = uLight[i];
                switch(l.type)
                {
                    case DIRECTIONAL:
                    {
                        vec3 vecToLight = -l.direction;
                        lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                    }
                    break;
                    case POINT:
                    {
                        vec3 vecToLight = normalize(l.position - aVertexPosition);
                        lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                    }
                    break;
                    case SPOT:
                    {
                        vec3 vecToLight = normalize(l.position - aVertexPosition);
                        if(dot(l.direction, -vecToLight) < l.angle)
                            lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                    }
                    break;
                    default:
                    break;
                }

                // diffuse
                diffusePart += vec4(l.color.xyz * lambert, 0.0);

                // specular
                if(lambert > 0)
                {
                    switch(uSpecularType)
                    {
                        case PHONG:
                        {
                            specVec = 2 * dot(aVertexNormal, vecToLight) * aVertexNormal - vecToLight;
                        }
                        break;
                        case BLINN:
                        {
                            specVec = 0.5 * (vecToLight + vecToViewer);
                        }
                        break;
                        default:
                        break;
                    }

                    specularPart += vec4(l.color.xyz * pow(dot(r, vecToViewer), uMaterial.roughness), 0.0);
                }
            }

            vPolygonColor = uMaterial.kA * ambientPart + uMaterial.kD * diffusePart + uMaterial.kS * specularPart;
        }
    </script>
    <script id="fs-flat" type="x-shader/x-fragment">
        varying vec4 vColor;

        void main()
        {
            gl_FragColor = vColor;
        }
    </script>

    <script id="vs-phong" type="x-shader/x-vertex">
        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;

        uniform vec4 uMaterialColor;
        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        uniform vec3 uCameraPosition;
        uniform int  uSpecularType;

        //lights
        uniform light_info uLight[64];
        uniform int uNumLights;
        uniform material_info uMaterial;


        varying vec4 vMaterialColor;

        struct light_info {
            int   type;
            vec4  color;
            vec4  position;
            vec4  direction;
            float angle;
        };
        struct material_info {
            float kA;
            float kD;
            float kS;
            float roughness;
        };

        // light types
        const int AMBIENT = 0;
        const int DIRECTIONAL = 1;
        const int POINT = 2;
        const int SPOT = 3;

        // specular types
        const int PHONG = 0;
        const int BLINN = 1;

        void main()
        {
            gl_Position = uMVPMatrix * vec4(aVertexPosition, 1.0);
            vec4 facePosition = PVMMatrix * vec4(aFacePosition, 1.0);

            //light
            vec4 ambientPart = uLight[0].color;
            vec4 diffusePart = vec4(0.0, 0.0, 0.0, 1.0);
            vec4 specularPart = vec4(0.0, 0.0, 0.0, 1.0;

            vec4 normal = uNormalMatrix * vec4(aVertexNormal, 1.0);

            vec3 vecToViewer = normalize(uCameraPosition - aVertexPosition);

            int max = min(uNumLights, 64);
            light_info l;
            float lambert;
            vec3 specVec;
            for(int i = 0, i < max; i++)
            {
                l = uLight[i];
                switch(l.type)
                {
                    case DIRECTIONAL:
                    {
                        vec3 vecToLight = -l.direction;
                        lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                    }
                    break;
                    case POINT:
                    {
                        vec3 vecToLight = normalize(l.position - aVertexPosition);
                        lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                    }
                    break;
                    case SPOT:
                    {
                        vec3 vecToLight = normalize(l.position - aVertexPosition);
                        if(dot(l.direction, -vecToLight) < l.angle)
                            lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                    }
                    break;
                    default:
                    break;
                }

                // diffuse
                diffusePart += vec4(l.color.xyz * lambert, 0.0);

                // specular
                if(lambert > 0)
                {
                    switch(uSpecularType)
                    {
                        case PHONG:
                        {
                            specVec = 2 * dot(aVertexNormal, vecToLight) * aVertexNormal - vecToLight;
                        }
                        break;
                        case BLINN:
                        {
                            specVec = 0.5 * (vecToLight + vecToViewer);
                        }
                        break;
                        default:
                        break;
                    }

                    specularPart += vec4(l.color.xyz * pow(dot(r, vecToViewer), uMaterial.roughness), 0.0);
                }
            }

            vMaterialColor = uMaterial.kA * ambientPart + uMaterial.kD * diffusePart + uMaterial.kS * specularPart;
        }
    </script>
    <script id="fs-phong" type="x-shader/x-fragment">
        varying vec3 normal;
        varying vec3

    </script>

    <script id="vs-gouraud" type="x-shader/x-vertex">
        struct light_info {
            int   type;
            vec4  color;
            vec3  position;
            vec3  direction;
            float angle;
            float exponent;
        };
        struct material_info {
            vec3 kA;
            vec3 kD;
            vec3 kS;
            float roughness;
            vec4  diffColor;
            vec4  specColor;
        };
        const int maxLights = 32;


        attribute vec3 aVertexPosition;
        attribute vec3 aVertexNormal;

        uniform mat4 uMVMatrix;
        uniform mat4 uMVPMatrix;
        uniform mat4 uNormalMatrix;
        uniform vec3 uCameraPosition;
        uniform int  uSpecularType;

        //lights
        uniform light_info uLight[maxLights];
        uniform int uNumLights;
        uniform material_info uMaterial;


        varying vec4 vColor;

        // light types
        const int AMBIENT = 0;
        const int DIRECTIONAL = 1;
        const int POINT = 2;
        const int SPOT = 3;

        // specular types
        const int PHONG = 0;
        const int BLINN = 1;

        void main()
        {
            gl_Position = uMVPMatrix * vec4(aVertexPosition, 1.0);

            //light
            vec4 ambientPart = uLight[0].color;
            vec4 diffusePart = vec4(0.0, 0.0, 0.0, 1.0);
            vec4 specularPart = vec4(0.0, 0.0, 0.0, 1.0);

            vec4 normal = uNormalMatrix * vec4(aVertexNormal, 1.0);

            vec3 vecToViewer = normalize(uCameraPosition - aVertexPosition);

            light_info l;
            float lambert;
            vec3 specVec;
            vec3 intensity;
            vec3 vecToLight;
            for (int i = 1; i < maxLights; i++)
            {
                if (i == uNumLights)
                    break;

                l = uLight[i];
                if (l.type == DIRECTIONAL)
                {
                    vecToLight = -l.direction;
                    intensity = l.color.xyz;
                    lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                }
                else if (l.type == POINT)
                {
                    vecToLight = normalize(l.position - aVertexPosition);
                    intensity = l.color.xyz;
                }
                else if (l.type == SPOT)
                {
                    vecToLight = normalize(l.position - aVertexPosition);
                    float angleCos = dot(l.direction, -vecToLight);
                    intensity = angleCos < cos(radians(l.angle)) ?
                                l.color.xyz * pow(max(angleCos, 0.0), l.exponent) :
                                vec3(0.0);
                }


                // diffuse
                lambert = max(dot(aVertexNormal, vecToLight), 0.0);
                diffusePart += vec4(intensity * lambert, 0.0);

                // specular
                vec3 specVec;
                float cosine;
                if(lambert > 0.0)
                {
                    if(uSpecularType == PHONG)
                    {
                        specVec = 2.0 * dot(aVertexNormal, vecToLight) * aVertexNormal - vecToLight;
                        cosine = pow(dot(specVec, vecToViewer), uMaterial.roughness);
                    }
                    else if (uSpecularType == BLINN)
                    {
                        specVec = 0.5 * (vecToLight + vecToViewer);
                        cosine = pow(dot(aVertexNormal, specVec), uMaterial.roughness);
                    }

                    specularPart += vec4(intensity * cosine, 0.0);
                }
            }

            vColor = vec4(uMaterial.kA, 1.0) * ambientPart
                                 + vec4(uMaterial.kD, 1.0) * diffusePart * uMaterial.diffColor,
                                 + vec4(uMaterial.kS, 1.0) * specularPart * uMaterial.specColor;
        }
    </script>
    <script id="fs-gouraud" type="x-shader/x-fragment">
        precision mediump float;

        varying vec4 vColor;

        void main()
        {
            gl_FragColor = vColor;
        }
    </script>

<!--SCRIPTS-->

    <!--general independent utility-->
    <script src="Scripts/gl-matrix.js" type="text/javascript"></script>
    <script src="Scripts/webgl-obj-loader.js" type="text/javascript"></script>
    <script src="Scripts/OOP/inheritance.js" type="text/javascript"></script>
    <script src="Scripts/OOP/event.js" type="text/javascript"></script>
    <script src="Scripts/file_reader.js" type="text/javascript"></script>
    <script src="Scripts/Input/input_manager.js" type="text/javascript"></script>
    <!--math-->
    <script src="Scripts/Math3D/vector.js" type="text/javascript"></script>
    <script src="Scripts/Math3D/matrix.js" type="text/javascript"></script>
    <!--shaders-->
    <script src="Scripts/Shaders/shader_loader.js" type="text/javascript"></script>
    <script src="Scripts/Shaders/materials.js" type="text/javascript"></script>
    <!--scene & sceneobject-->
    <script src="Scripts/Scene/scene.js" type="text/javascript"></script>
    <script src="Scripts/Scene/SceneObject/scene_object.js" type="text/javascript"></script>
    <!--composites-->
    <script src="Scripts/Scene/SceneObject/composite.js" type="text/javascript"></script>
    <script src="Scripts/Scene/SceneObject/Composite/mesh_renderer.js" type="text/javascript"></script>
    <script src="Scripts/Scene/SceneObject/Composite/transform.js" type="text/javascript"></script>
    <script src="Scripts/Scene/SceneObject/Composite/camera.js" type="text/javascript"></script>
    <script src="Scripts/Scene/SceneObject/Composite/light.js" type="text/javascript"></script>
    <script src="Scripts/Scene/SceneObject/Composite/script.js" type="text/javascript"></script>

    <!--init: this should be loaded last-->
    <script src="Scripts/init.js" type="text/javascript"></script>
</body>
</html>